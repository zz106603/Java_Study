<h1>#whiteship(백기선) 자바 기초 스터디 1주차</h1>



<h2>JVM이란?</h2>

- 자바 가상 기계(Java  Virtual Machine)

- 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제 역할

- OS별로 프로그램을 실행하고 관리하는 방법이 다르기 때문에 중계하는 JVM을 두어 여러 OS에서 동일한 실행 결과가 나오게 함.

- OS에 종속적이라서 맞게 설치해야 함.

- JVM에 의해 기계어로 번역되고 실행되기 때문에 C, C++의 컴파일 단계에서 만들어진 완전한 기계어보다는 **속도가 느린 단점이 존재.**

  

<h4>영역</h4>

- **메서드 영역**
  - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보와 그 클래스의 변수를 이곳에 저장
  - 클래스 변수 : 전역변수, 한 번 선언되면 해당 클래스의 모든 인스턴스가 같은 저장공간을 가리킴.
- **힙**
  - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스들이 모두 여기에 저장된다. 즉, 인스턴스 변수들이 생성되는 공간
  - 인스턴스 변수 : 인스턴스에 종속되어 생성 시 새로운 저장공간을 할당.
- **호출스택**
  - 메서드의 작업이 필요한 메모리 공간을 제공. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당
  - 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용되며, 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 지워진다.



<h4>동작 과정</h4>

- ![img](https://blog.kakaocdn.net/dn/d6sHeb/btqBGrmPs15/5uHgxnLrVNu4kDgsH5xfo0/img.png)
  1. 프로그램이 실행되면 JVM은 OS로부터 메모리를 할당받는다. 영역에 따라 나누어 관리
  2. 자바 컴파일러가 자바 소스코드를 읽어들어 자바 바이트코드(.class)로 변환
  3. Class Loader를 통해 class파일들을 JVM으로 로딩
  4. 로딩된 class파일들은 Excution engine을 통해 해석
  5. 해석된 바이트코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어짐
  6. 위의 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization, GC같은 관리 작업을 수행



<h4>구성 요소</h4>

- **Class Loader**
  - JVM 내로 클래스 파일을 load하고 link를 통해 배치를 수행하는 모듈로 Runtime 시에 동적으로 클래스를 로드한다.
  - 자바는 동적 코드, 컴파일 타임이 아니라 런타임에 참조
  - 즉, 클래스를 처음으로 참조할 때 해당 클래스를 load하고 link한다.
- **Execution Engine**
  - class loader를 통해 배치된 클래스를 실행한다.
  - 클래스 파일(바이트 코드)은 비교적 인간이 보기 쉬운 형태이기 때문에 기계가 실행할 수 있는 형태로 변형시키는데 이 때, 두 가지 방식을 사용( 인터프리터, JIT)
- **Interpreter**
  - 실행 엔진은 바이트 코드를 명령어 단위로 실행, 한 줄 씩 실행하기 때문에 느리다는 단점이 존재
- **JIT (Just-In-Time)**
  - interpreter 방식의 단점을 보완하기 위해 도입된 방식
  - interpreter 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하여 네이티브 코드로 변경하고, 더 이상 interpreting 하지 않고 네이티브 코드로 직접 실행하는 방식
  - 네이티브 코드는 캐시에 보관되기 때문에 한 번 컴파일된 코드는 빠르게 실행 가능
  - 한 번만 실행되는 코드라면 JIT보다 Interpreter 방식이 유리
  - 따라서 JVM은 해당 메소드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때 컴파일을 수행



<h2>컴파일, 실행 방법?</h2>

<h3>CMD</h3>

- <h4>패키지가 없는 자바 파일</h4>

  1. 자바 파일이 있는 곳으로 이동 ex) helloworld
  2. 컴파일 실행
     - **javac helloworld.java**
  3. helloworld.class 파일이 만들어 짐

  4. 자바 실행
     - **java helloworld**

- <h4>패키지에 포함된 자바 파일</h4>

  1. 패키지 시작부분(src 폴더)으로 이동
  2. 컴파일 실행
     - **javac ./test/helloworld.java**
  3. 자바 실행
     - **java ./test/helloworld**



<h2>자바 바이트 코드?</h2>

- 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미
- 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있음.
- .class 확장자
- JVM만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있음.



<h2>JIT( Just-In-Time ) 컴파일러란?</h2>



<h4>개요</h4>

- 바이트코드가 애플리케이션에 대한 적절한 기본 명령어로 변환되는 방식은 애플리케이션의 속도에 큰 영향을 미친다. 이러한 바이트 코드는 해석되거나 원시 코드로 컴파일되거나 명령어 세트 아키텍처가 바이트 코드 사양 인 프로세서에 직접 실행될 수 있다.

- **JVM의 표준 구현 인 바이트 코를 해석하면 프로그램 실행 속도가 느려진다.**

- 성능 향상을 위해 JIT 컴파일러는 런타임에 JVM과 상호 작용하고 적절한 바이트 코드 시퀀스를 원시 기계 코드로 컴파일

- JIT 컴파일러를 사용할 때 하드웨어는 **JVM이 동일한 바이트 코드 시퀀스를 반복적으로 해석하고 상대적으로 긴 변환 프로세스의 패널티를 초래하는 것과는 반대로 원시 코드를 실행**할 수 있다.

  - 이것은 실행 속도 성능 향상으로 이어질 수 있다.

    

<h4>작동 원리</h4>

- 런타임 시 Java 애플리케이션의 성능을 향상시키는 Java Runtime Environment의 구성 요소
- 런타임에 JVM은 **클래스 파일을 로드**하고 각 개별 바이트 코드의 의미를 결정하고 적절한 계산을 수행
- 런타임에 **바이트 코드를 원시 기계 코드로 컴파일**하여 java 프로그램의 성능을 향상 시킴
- ![img](https://blog.kakaocdn.net/dn/bFV3Wt/btqG68RvEaq/dUMj5kiqu5Zb0iEIxTGnCK/img.png)



<h2>JRE, JDK 차이점?</h2>



<h4>JRE : 컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경</h4>

- JVM이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있다.
- JVM의 실행환경을 구현했다고 할 수 있다.
- 자바 프로그램을 **실행**시키기 위해선 JRE를 반드시 설치
- But, **자바 프로그래밍 도구**는 포함되어있지 않기 때문에 **자바 프로그래밍**을 하기 위해선 JDK가 필요



<h4>JDK : 자바 프로그래밍시 필요한 컴파일러 등 포함</h4>

- 개발에 필요한 도구(javac, java등)들을 포함한다.
- JDK를 설치하면 JRE도 같이 설치가 된다.
- 즉, **JDK = JRE + @** 